const vmt_LS
	:LS.Start
	:LS.Print
	:LS.Search
	:LS.Init
func Main()
	t.0 = HeapAllocZ(12)
	[t.0] = :vmt_LS
	if t.0 goto :null1
		Error("null pointer")
	null1:
	t.1 = [t.0]
	t.2 = [t.1+0]
	t.3 = call t.2(t.0 10)
	PrintIntS(t.3)
	ret
func LS.Start(this sz)
	t.4 = [this]
	t.5 = [t.4+12]
	t.6 = call t.5(this sz)
	aux01 = t.6
	t.7 = [this]
	t.8 = [t.7+4]
	t.9 = call t.8(this sz)
	aux02 = t.9
	PrintIntS(9999)
	t.10 = [this]
	t.11 = [t.10+8]
	t.12 = call t.11(this 8)
	PrintIntS(t.12)
	t.13 = [this]
	t.14 = [t.13+8]
	t.15 = call t.14(this 12)
	PrintIntS(t.15)
	t.16 = [this]
	t.17 = [t.16+8]
	t.18 = call t.17(this 17)
	PrintIntS(t.18)
	t.19 = [this]
	t.20 = [t.19+8]
	t.21 = call t.20(this 50)
	PrintIntS(t.21)
	ret 55
func LS.Print(this)
	j = 1
	while1_top:
	t.22 = LtS(j size)
	if0 t.22 goto :while1_end
		t.23 = [this + 4]
		if t.23 goto :null2
			Error("null pointer")
		null2:
		t.24 = [t.23]
		t.24 = Lt(j t.24)
		if t.24 goto :bounds1
			Error("array index out of bounds")
		bounds1:
		t.24 = MulS(j 4)
		t.24 = Add(t.24 t.23)
		t.25 = [t.24 + 4]
		PrintIntS(t.25)
		t.26 = Add(j 1)
		j = t.26
		goto :while1_top
	while1_end:
	ret 0
func LS.Search(this num)
	j = 1
	ls01 = 0
	ifound = 0
	while2_top:
	t.27 = LtS(j size)
	if0 t.27 goto :while2_end
		t.28 = [this + 4]
		if t.28 goto :null3
			Error("null pointer")
		null3:
		t.29 = [t.28]
		t.29 = Lt(j t.29)
		if t.29 goto :bounds2
			Error("array index out of bounds")
		bounds2:
		t.29 = MulS(j 4)
		t.29 = Add(t.29 t.28)
		t.30 = [t.29 + 4]
		aux01 = t.30
		t.31 = Add(num 1)
		aux02 = t.31
		t.32 = LtS(aux01 num)
		if0 t.32 goto :if1_else
		nt = 0
			goto :if1_end
		if1_else:
		t.33 = LtS(aux01 aux02)
		t.34 = Sub(t.33 1)
		if0 t.34 goto :if2_else
		nt = 0
			goto :if2_end
		if2_else:
			ls01 = 1
			ifound = 1
			j = size
		if2_end:
		if1_end:
		t.35 = Add(j 1)
		j = t.35
		goto :while2_top
	while2_end:
	ret ifound
func LS.Init(this sz)
	t.36 = [this + 8]
	size = t.36
	t.37 = [this + 4]
	number = t.37
	j = 1
	t.38 = Add(size 1)
	k = t.38
	while3_top:
	t.39 = LtS(j size)
	if0 t.39 goto :while3_end
		t.40 = MulS(2 j)
		aux01 = t.40
		t.41 = Sub(k 3)
		aux02 = t.41
		t.42 = [this + 4]
		if t.42 goto :null4
			Error("null pointer")
		null4:
		t.43 = [t.42]
		t.43 = Lt(j t.43)
		if t.43 goto :bounds3
			Error("array index out of bounds")
		bounds3:
		t.43 = MulS(j 4)
		t.43 = Add(t.43 t.42)
		t.44 = Add(aux01 aux02)
		[t.43 + 4] = t.44
		t.45 = Add(j 1)
		j = t.45
		t.46 = Sub(k 1)
		k = t.46
		goto :while3_top
	while3_end:
	ret 0


func AllocArray(size)
	bytes = MulS(size 4)
	bytes = Add(bytes 4)
	v = HeapAllocZ(bytes)
	[v] = size
	ret v
